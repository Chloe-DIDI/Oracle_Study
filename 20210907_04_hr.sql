SELECT USER
FROM DUAL;
--==>> HR



--■■■ 정규화(Nomalization) ■■■--

--○ 정규화란?
--   한 마디로 데이터베이스 서버의 메모리 낭비를 막기 위해
--   어떤 하나의 테이블을 식별자를 가리는 여러 개의 테이블로
--   나누는(분리하는, 쪼개는) 과정을 말한다.

-- ex) 범석이가 옥장판을 판매한다.
--     고객리스트 → 거래처직원 명단이 적혀있는 수첩의 정보를 데이터베이스화 하려고 한다.

-- 테이블명 : 거래처직원
/*
  10byte        10byte      10byte      10byte    10byte  10byte   10byte
--------------------------------------------------------------------------
거래처회사명   회사주소    회사전화    거래처직원  직급  이메일   휴대폰
--------------------------------------------------------------------------
    LG       서울여의도  02-345-6789     정미화     부장  jmh@na.. 010-...
    LG       서울여의도  02-345-6789     장진하     대리  cjh@da.. 010-...
    LG       서울여의도  02-345-6789     김소연     과장  ksy@gm.. 010-...
    LG       서울여의도  02-345-6789     김진희     부장  kjh@na.. 010-...
    SK       서울여의도  02-123-5678     최수지     대리  csj@na.. 010-... 
    LG       부산동래구  051-7777-8888   정미화     대리  kjr@da.. 010-...
                                    :
                                    :
*/
/*
가정) 서울여의도  LG 라는 회사에 근무하는 거래처 직원 명단이
      총 100만 명이라고 가정한다.
      (한 행(레코드)은 70byte 이다.)
      
      어느날...『서울여의도』에 위치한 『LG』본사가
      『경기분당』으로 사옥을 이전하게 되었다.
      이로 인해...
      회사주소는 『경기분당』으로 바뀌고,
      회사전화는 『031-1111-2222』로 바뀌게 되었다.
      
      그러면... 100만 명의 회사주소와 회사전화를 변경해야 한다.
      
      -- 이 때 수행되어야 할 쿼리문 → UPDATE 구문
      
      UPDATE 거래처직원
      SET 회사주소='경기분당', 회사전화='031-1111-2222'
      WHERE 거래처회사명='LG'
        AND 회사주소='서울여의도'
        
      --> 100만 개 행을 하드디스크 상에서 읽어다가 
          메모리에 로드시켜 주어야 한다.
          즉, 100만 * 70Byte 를 모두
          하드디스크 상에서 읽어다가 메모리에 로드시켜 주어야 한다는 말이다.
          
          --> 이는 테이블의 설계가 잘못되었으므로
              db 서버는 조만간 메모리 고갈로 인해 DOWN 될 것이다.
              
              --> 그러므로 정규화 과정을 수행해야 한다.
*/

--○ 제 1 정규화

--> 어떤 하나의 테이블에 반복되어 컬럼 값들이 존재한다면
-- 값들이 반복되어 나오는 컬럼을 분리하여
-- 새로운 테이블을 만들어준다.

--> 제 1 정규화를 수행하는 과정에서 분리된 테이블은
--  반드시 부모 테이블과 자식 테이블의 관계를 갖게 된다.

--> 부모 테이블 → 참조받는 컬럼 → PRIMARY KEY
--  자식 테이블 → 참조하는 컬럼 → FOREIGN KEY

--※ 참조받는 컬럼이 갖는 특징(부모 테이블)
--   - 반드시 고유한 값(데이터)이 들어와야 한다.
--     즉, 중복된 값(데이터)이 없어야 한다.
--   - NULL 이 있어서는 안된다. (NOT NULL 이어야 한다.)--?? 널이랑 낫널 차이가 뭐지?

--> 제 1 정규화를 수행하는 과정에서 부모 테이블의 PRIMART KEY 는
--  항상 자식 테이블의 FOREIGN KEY
/*
-- 테이블명 : 회사 → 부모 테이블
  10byte        10byte      10byte      10byte    
----------------------------------------------------
  회사ID   거래처회사명   회사주소    회사전화    
 -------
 (참조받는컬럼 → P,K)
----------------------------------------------------
    10          LG       서울여의도  02-345-6789     
    20          SK       서울소공동  02-345-6789     
    30          LG       부산동래구  051-7777-8888   
----------------------------------------------------            
*/

-- 테이블명 : 직원 → 자식 테이블
/*
  10byte     10byte  10byte   10byte    10byte  
-------------------------------------------------
  거래처직원   직급  이메일   휴대폰   회사ID
                                       -------
                                       (참조하는컬럼 → F,K)
-------------------------------------------------
  정미화       부장  jmh@na.. 010-...    10
  장진하       대리  cjh@da.. 010-...    10
  김소연       과장  ksy@gm.. 010-...    10
  김진희       부장  kjh@na.. 010-...    10
  최수지       대리  csj@na.. 010-...    20
  정미화       대리  kjr@da.. 010-...    30
                  :
-------------------------------------------                                    
*/

--※ 테이블이 분할(분리)되기 이전 상태로 조회
/*
SELECT A.거래처회사명, A.회사주소, A.회사전화, B.거래처직원, B.직급, B.이메일, B.휴대폰
FROM 회사 A, 직원 B
WHERE A.회사ID =  B.회사ID;
*/

/* 
가정) 서울여의도 LG 라는 회사에 근무하는 거래처 직원 명단이
      총 100만 명이라고 가정한다.
      
      
      어느날...『서울여의도』에 위치한 『LG』본사가
      『경기분당』으로 사옥을 이전하게 되었다.
      이로 인해...
      회사주소는 『경기분당』으로 바뀌고,
      회사전화는 『031-1111-2222』로 바뀌게 되었다.
      
      그러면... 회사 테이블에서 1건의 회사주소와 회사전화를 변경해야 한다.      CHECK~!!!
      
      -- 이 때 수행되어야 할 쿼리문 → UPDATE 구문
      
      UPDATE 회사
      SET 회사주소='경기분당', 회사전화='031-1111-2222'
      WHERE 회사ID=10;
        
      --> 1 개 행(회사ID=10, 즉, 회사ID가 10인 것)을 하드디스크 상에서 읽어다가 
          메모리에 로드시켜 주어야 한다.
          즉, 10 * 40Byte 를 
          하드디스크 상에서 읽어다가 메모리에 로드시켜 주어야 한다는 말이다.
          
          --> 이는 테이블의 설계가 잘 된 상황이다.
              
              --> 정규화를 수행하기 이전에는 100만 건을 처리해야 할 업무에서
                  1 건만 처리하면 되는 업무로 바뀐 상황이기 때문에
                  DB 서버는 메모리 고갈 없이 아주 빠르게 처리될 것이다.
*/

-- A.거래처회사명, 회사전화
/*
SELECT 거래서회사명, 회사전화                    |   SELECT 거래처 회사명, 회사전화
FROM 회사                                        |   FROM 거래처직원
→ 레코드 3개, * 40Byte                          |   → 200만 * 70Byte

--> 왼쪽이 더 바람직
                                                --> 오른쪽이 크다 그래서 별루 비효율적,, 
                                                    밑에 B, C 도 마찬가지
*/

-- B.거래처직원명, 직급
/*
SELECT 거래처직원명, 직급                         | SELECT 거래처직원명, 직급
FROM 직원                                         | FROM 거래처직원
→ 200만 * 50Byte                                 | → 200만 * 70Byte

*/

-- C.거래처회사명, 거래처직원명
/*
SELECT회사, 거래처회사명, 직원, 거래처직원명     | SELECT 거래처회사명, 거래처직원명
FROM 회사 JOIN 직원                              | FROM 거래처직원
ON 회사, 회사ID = 직원.회사ID;                   | → 200만 * 70Byte
→ ( 3 * 40Byte ) + (200만 * 50Byte)            
    -----------      --------------
        A                  B

*/
/*
---->> 다른 예시
-------------------------------------------------------------------------
고객ID              제품코드               주문일자         주문수량
++++++++++++++++++++++++++++++++++++++++++++++++++++++
                    P.K
-------------------------------------------------------------------------
SSK1127(서승균)   SWK9984(새우깡)     2021-08-02 11:27:31     50
SHD7766(송해덕)   YPR8866(양파링)     2021-08-02 11:31:43     30
PHB7755(박효빈)   CPI1100(초파이)     2021-08-02 11:45:54     20
PHB7755(박효빈)   SWK9984(새우깡)     2021-08-02 15:00:03     20
SHD7766(송해덕)   CPI1100(초파이)     2021-08-03 05:12:12     12
                                :
--------------------------------------------------------------------------                        

--※ 하나의 테이블에 존재하는 PRIMARY KEY 의 최대 갯수는 1개이다.
--   하지만, PRIMARY KEY 를 이루는(구성하는) 컬럼의 갯수는
--   복수(다수, 여러개)인 것이 가능하다.
--   컬럼 1개로만 (단일 컬럼) 구성된 PRIMARY KEY를 Single Primary Key 라고 부른다. (단일 프라이머리 키)
--   두 개 이상의 컬럼으로 구성된 PRIMARY KEY를 Composite Primary Key 라고 부른다. (복합 프라이머리 키)

*/
---------------------------------------------------- 1 정규화 끝
-- 정규화란 나누고 쪼개고 분리하는 거다
-- 왜 정규하하냐? DB 서버 과부하를 막기위해서
-- 정규화도 순서대로 1정규화, 2정규화 등등 해야된다.


--○ 제 2 정규화
--> 제 1 정규화를 마친 결과물에서 PRIMARY KEY 가 SINGLE COLUMN 이라면
--  제 2 정규화는 수행하지 않는다.
--  하지만, PRIMARY KEY 가 COMPOSITE COLUMN 이라면
--  반.드.시. 제 2정규화를 수행해야 한다.

--> 식별자가 아닌 컬럼은 식별자들 전체 컬럼에 대해 의존적이어야 하는데
--  식별자 전체 컬럼이 아닌 일부 식별자 컬럼에 대해서만 의존적이라면
--  이를 분리하여 새로운 테이블 생성해 준다.

/*
-----------------------------------------------------------------------------------------------------------------------------
과목번호    과목명       교수자번호  교수자명   강의실코드  강의실설명  과목번호    교수자번호   학번      학생명     점수
-----------------------------------------------------------------------------------------------------------------------------
 ㄴ 원래 이런것






테이블명 : 과목 → 부모 테이블
------------------------------------------------------------------------------------
과목번호    과목명       교수자번호  교수자명   강의실코드  강의실설명            -->> 과목번호는 과목명과 연결되어잇고 
++++++++                 ++++++++++                                               -->> 교수번호는 교수가명이 따라가니까 이게 2정규화        
(P              .               K)                                                -->> (식별자가아닌컬럼)강의실설명은 강의실 코드를 따라감 -> 제 3 정규화
------------------------------------------------------------------------------------
JV0101      자바기초     21          슈바이처   A301        전산실습관 3층 30석 규모
JV0102      자바중급     22          테슬라     T502        전자공학관 5층 20석 규모
DB0102      오라클중급   22          테슬라     A201        전산실습관 2층 50석 규모
DB0102      오라클중급   10          장영실     T502        전자공학관 5층 20석 규모
DB0103      오라클고급   22          테슬라     A203        전산실습관 2층 90석 규모
JS0105      JSP심화      10          장영실     K101        인문사회관 1층 80석 규모
                                        :
                                        :
------------------------------------------------------------------------------------
테이블명 : 점수 → 자식 테이블
---------------------------------------------------
과목번호    교수자번호   학번      학생명     점수
======================
       (F.K)
++++++++                 ++++
(P           .             K)
---------------------------------------------------
DB0102      22           1902110   김진희     80
DB0102      22           1902127   장진하     70
                        :
                        :
---------------------------------------------------
*/


--------------------------------------------------------------------------------

--○ 제 3 정규화
--> 식별자가 아닌 컬럼이 식별자가 아닌데 여기 컬럼에 의존적인 상황이라면
--  이를 분리하여 새로운 테이블을 생성해 주어야 한다.

--------------------------------------------------------------------------------

--※ 관계(Relation)의 종류

-- 1 : 1

-- 1 : 다
--> 제 1 정규화를 마친 결과물에서 나타나는 바람직한 관계.
--  관계형 데이터베이스를 활용하는 과정에서 추구해야 하는 관계.

-- 다 : 다
--> 논리적인 모델링에서는 존재할 수 있지만
--  실제 물리적인 모델링에서는 존재할 수 없는 관계.

/*
테이블명 : 고객 (다)                   테이블명 : 제품 (다)
---------------------------           ----------------------------
고객번호 고객명 이메일 ...            제품코드 제품명 제품단가 ...
++++++++                              ++++++++
 (P.K)                                 (P.K)
---------------------------           ----------------------------
  1100   장민지 ....                    swk    새우깡 1500
  1101   최현정 ....                    ggk    감자깡  700
  1102   윤유동 ....                    ggc    자갈치  500
           :                                        :
---------------------------           -----------------------------

                   테이블명 : 주문등록 (파생 테이블)
                 --------------------------------------
    주문번호       고객번호  제품코드 주문일자 주문수량
     (p.k)          (f.k)     (f.k)       
                 --------------------------------------
                    1100       swk     ......     30
                    1100       ggk     ......     50
                    1101       ggc     ......     11
                    1101       swk     ......     20
                    1102       ggk     ......     10
                    1102       ggc     ......     20
                ---------------------------------------
*/

--○ 제 4 정규화
-->  위에서 확인한 내용과 같이 『다:다』 관계를 『1:다』 관계로 깨뜨리는 과정이
--   제 4 정규화의 수행 과정이다.
--   → 일반적으로 파생 테이블 생성
--      → 『다:다』 관계를 『1:다』 관계로 깨뜨리는 역할 수행


--------------------------------------------------------------------------------

--○ 역정규화(비정규화)
/*
=========================================================
-- A 경우 → 역정규화를 수행하지 않는 것이 바람직한 경우
=========================================================

테이블명 : 부서                     테이블명 : 사원
10Byte      10Byte     10Byte       10Byte   10Byte 10Byte 10Byte 10Byte 10Byte    10Byte
------------------------------      --------------------------------------------- --------
부서번호    부서명     주소         사원번호 사원명 직급  급여  입사일 부서번호  + 부서명
++++++++                            ++++++++                           =========   
 (P.K)                                (P.K)                              (F.K)
------------------------------      --------------------------------------------- --------
          10개 행                                   1,000,000개 행
------------------------------      --------------------------------------------- --------
   ㄴ★★★이것과 이것의 크기(숫자) 차이가 많이 나면 역정규화 안하는게 낫다」        ㄴ 컬럼 한개 추가!
>> 업무 분석 상 조회 결과물
-------------------------
부서명 사원명 직급 급여
-------------------------
부서    사원  사원 사원
--> Q. 부서 하나 때문에 두 테이블의 메모리를 다 퍼올릴 것인가?
--> A. YES(한 테이블의 데이터 수가 적을 경우)
→ 『부서』테이블과 『사원』테이블을 JOIN 했을 때의 크기
    (10 * 30Byte)  +  (1,000,000 * 60Byte) = 300 + 60,000,000 = 60,000,300Byte
    
→ 『사원』테이블을 역정규화 수행한 후 이 테이블만 읽어올 때의 크기 <역정규화> 
    (즉, 부서 테이블의 부서명 컬럼을 사원 테이블에 추가한 경우 cf. 참조관계는(부서번호) 유지하되)
    1,000,000 * 70Byte = 70,000,000Byte
                -----사원테이블에서 사원번호,  사원명,직급, 급여, 입사일, 부서번호, 부서명 -> 총 7개라 70 Byte

====================================================
-- B 경우 → 역정규화를 수행하는 것이 바람직하다.
====================================================

테이블명 : 부서    (부모)           테이블명 : 사원     (자식)
10Byte      10Byte     10Byte       10Byte   10Byte 10Byte 10Byte 10Byte 10Byte    10Byte
------------------------------      --------------------------------------------- --------
부서번호    부서명     주소         사원번호 사원명 직급  급여  입사일 부서번호  + 부서명
++++++++                            ++++++++                           =========   
 (P.K)                                (P.K)                              (F.K)
------------------------------      --------------------------------------------- --------
       500,000개 행                                   1,000,000개 행
------------------------------      --------------------------------------------- --------
>> 업무 분석 상 조회 결과물
-------------------------
부서명 사원명 직급 급여
-------------------------
부서    사원  사원 사원
--> Q. 부서 하나 때문에 두 테이블의 메모리를 다 퍼올릴 것인가?
--> A. NO(한 테이블의 데이터 수가 많을 경우)
→ 『부서』테이블과 『사원』테이블을 JOIN 했을 때의 크기
    (500,000 * 30Byte)  +  (1,000,000 * 60Byte) = 15,000,000 + 60,000,000 = 75,000,000Byte
    
→ 『사원』테이블을 역정규화 수행한 후 이 테이블만 읽어올 때의 크기 <역정규화>
    (즉, 부서 테이블의 부서명 컬럼을 사원 테이블에 추가한 경우 cf. 참조관계는(부서번호) 유지하되)
    1,000,000 * 70Byte = 70,000,000Byte
    
--==>> A, B 를 비교해보면 
       A는 10행밖에안되지만 B는 500,000개 행이 가능하고
       하지만 사원과 이걸 JOIN 하고 역정규화 했을 때 70,000,000Byte 똑같기때문에 B가 역정규화한게 더 좋다.
*/

/*
테이블명 : 사원 → 부모 테이블(WHY? 사원번호가 고유한 번호라서,,)
---------------------------------------------------
사원번호  사원명  주민번호  입사일  급여 ★직급 ...            
++++++++                                  ======
 (P.K)                                     (F.K)      -----▶       테이블명 : 직급            
---------------------------------------------------             -------------------------
7369      장진하  9XXXXXX   2010-XX  XXX  부장  ...                      코드
7370      김진희  9XXXXXX   2011-XX  XXX  차장  ...             -------------------------
7371      장민지  9XXXXXX   2010-XX  XXX  과장  ...                  1    부장급
7372      손범석  9XXXXXX   2010-XX  XXX  대리  ...                  2    차장급
7373      이찬호  9XXXXXX   2011-XX  XXX  사원  ...                  3    과장급(팀장, ...)
                     :                                               4    대리급(주임, ...)
                     :                                                  
---------------------------------------------------                     
                       
테이블명 : 사원가족 → 자식 테이블 (여기는 사원번호 고유하지 않음)
--------------------------------------
주민번호  사원번호  ★관계코드  성명    
++++++++  ========    ~~~~~~~~~                         테이블명 : 관계 (필요)
 (P.K)      (F.K)           ㄴ-------------------▶   --------------------------
--------------------------------------                          코드
9XXXXXXX    7369        남편  송강희                  --------------------------
0XXXXXXX    7369        아들  송강호                  관계코드 관계자명 관계설명
9XXXXXXX    7370        아내  송지효                     1       아내      ..
9XXXXXXX    7371        남편  남주혁                     3       남편      ..
                  :                                      4       딸        ..
--------------------------------------                   5       부모님    ..
                                                      --------------------------
                    
 

*/

-->  직급, 관계의 경우 따로 컬럼화해서 코드로 나타내지 않으면 
--   각 회사별(대리, 주임, 주무관...), 개인별(아내, 배우자, 부인 ...)로 
--   쓰는 호칭이 다를 수 있기 때문에 분류할 수 없다.
--   때문에 코드화해서 데이터가 입력될 수 있도록 테이블 구조를 짜야한다.















